---
id: downloader
sidebar_label: 下载
title: 使用下载组件
description: 下载组件为透过callback触发下载事件、提供了一种便捷的解决方案。
slug: /usages/downloader
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import IconExternalLink from "@theme/Icon/ExternalLink";
import vsiCheckIcon from "@iconify-icons/codicon/check";

import InlineIcon from "@site/src/components/InlineIcon";
import IconLink, {IconLinkInline} from "@site/src/components/IconLink";

## 使用`PlainDownloader`组件 {#use-the-plaindownloader-component}

Dash File Cache提供了一个定制化的组件，用来透过callback触发下载事件。

```python
downloader = PlainDownloader(id: str)
```

以下代码对比了分别使用、和不使用`PlainDownloader`的实现。这两种实现的效果是等价的。

<Tabs
  defaultValue="with-downloader"
  values={[
    { label: '使用Downloader', value: 'with-downloader', },
    { label: '不使用Downloader', value: 'without-downloader', },
  ]
}>

<TabItem value="with-downloader">

```python title="with_plain_downloader.py" showLineNumbers
import io

from typing import Optional

import dash
from dash import html
from dash import Output, Input
import dash_file_cache as dfc


app = dash.Dash("demo")
service = dfc.ServiceData(dfc.CachePlain(1))
# highlight-next-line
service.serve(app)

app.layout = html.Div(
    (
        html.Div(html.Button(id="btn", children="Download")),
        # highlight-next-line
        dfc.PlainDownloader(id="downloader")
    )
)


# highlight-next-line
@app.callback(Output("downloader", "url"), Input("btn", "n_clicks"))
def a_callback_creating_data(n_clicks: Optional[int]) -> str:
    if not n_clicks:
        return dash.no_update
    address = service.register(
        fobj=io.StringIO("test file data..."),
        file_name="test.txt",
        mime_type="text/plain",
        one_time_service=True,
        # highlight-next-line
        download=True,
    )
    return address


if __name__ == "__main__":
    app.run()
```

</TabItem>

<TabItem value="without-downloader">

```python title="without_downloader.py" showLineNumbers
import io

from typing import Optional

import dash
from dash import html
from dash import Output, Input
import dash_file_cache as dfc


app = dash.Dash("demo")
service = dfc.ServiceData(dfc.CachePlain(1))
# highlight-next-line
service.serve(app)

app.layout = html.Div(
    (
        html.Div(html.Button(id="btn", children="Download")),
        html.Div(id="downloader-js-finish-trigger", hidden=True),
        html.Div(id="downloader-js-trigger", hidden=True),
        html.Div(id="downloader-trigger", hidden=True),
    )
)


@app.callback(Output("downloader-trigger", "children"), Input("btn", "n_clicks"))
def a_callback_creating_data(n_clicks: Optional[int]) -> str:
    if not n_clicks:
        return dash.no_update
    address = service.register(
        fobj=io.StringIO("test file data..."),
        file_name="test.txt",
        mime_type="text/plain",
        one_time_service=True,
        # highlight-next-line
        download=True,
    )
    return address


@app.callback(
    Output("downloader-js-trigger", "children"),
    Input("downloader-trigger", "children"),
    prevent_initial_call=True,
)
def download_redirect(trigger: Optional[str]):
    """Trigger of download link redirection."""
    if not trigger:
        return dash.no_update
    return trigger


app.clientside_callback(
    """
    function (uri) {
        var link = document.createElement("a");
        link.setAttribute("download", "");
        link.setAttribute("target", "_blank");
        link.setAttribute("rel", "no-refresh");
        link.href = uri;
        document.body.appendChild(link);
        link.click();
        link.remove();
        return "success";
    }
    """,
    Output("downloader-js-finish-trigger", "children"),
    Input("downloader-js-trigger", "children"),
    prevent_initial_call=True,
)


if __name__ == "__main__":
    app.run()
```

</TabItem>

</Tabs>


`PlainDownloader(...)`是最简单的、用来提供下载功能的组件。透过触发属性`url`的callback，可以立即触发一个下载事件。

`PlainDownloader`背后实现的逻辑、和上例`without_downloader.py`的做法是完全一致的。在触发`url`的callback时，会临时创建一个不可见的`<a>`标签、并自动点击它。下载事件开始后，就会移除该`<a>`标签。标签所设的地址、由`ServiceData(...)`的缓存提供。

:::tip

将文件注册到缓存时，切记指定`file_name`的值，并且标记`download=True`。这些设置确保了动态生成的链接必定会触发下载事件，且所下载文件的文件名由`file_name`指定。

:::

## 使用该下载组件的理由 {#why-should-we-use-this-downloader}

直到`dash==3.0.x`，[`dcc.Download`<IconExternalLink/>][link-dccdownload]组件仍然直接作用于字节串数据。这意味着，数据会先在服务端编码成字节串、然后发送到客户端（浏览器）。换言之，[`dcc.send_file`<IconExternalLink/>][link-dash-sendfile]不是[`flask.send_file`<IconExternalLink/>][link-flask-sendfile]的封装。它无法处理大体量的数据。

与此同时，由于[`dcc.Download`<IconExternalLink/>][link-dccdownload]是透过[`FileSaver.js`<IconExternalLink/>][link-filesaver]实现的，它只能在下载数据之前，将全部数据预存在`blob`里。这意味着`dcc.Download`也没有能力处理大体量数据。

相对地，这里提供的解决方案，是基于[`flask.stream_with_context`<IconExternalLink/>][link-flask-streamwcon]的。下载组件直接访问可下载数据的地址、从而确保了与任意大小的数据兼容。


`PlainDownloader`透过一个临时超链接来实现。亦即是说，它下载文件时、完全依赖于浏览器的原生功能。故而，在以下应用场景里不会有任何问题：

* 下载一个大体量文件。
* 跨域访问一个文件（亦即下载来自其他站点的文件），哪怕服务端不允许跨域访问。

## 使用具有更细粒度的`Downloader`组件 {#use-a-downloader-component-with-more-fine-grained-controls}

在大多情形下，`dfc.PlainDownloader`已经是足够有用了。然而，如果用户需要以下功能，则应当考虑使用更细粒度版本的`dfc.Downloader`。

* 用户需要在下载事件结束时、触发一个callback。
* 用户需要捕获下载事件引发的错误，例如断线、或者取消下载。

`dfc.PlainDownloader`处理不了这些情景，这是因为它的下载事件完全委派给了浏览器，以至于它不具备控制、检查下载事件的能力。相对地、`dfc.Downloader`实现的下载事件、完全处于javascript模块[`StreamSaver.js`<IconExternalLink/>][link-streamsaver]的控制下，故而允许更细粒度的控制。

```python title="with_downloader.py" showLineNumbers
import io

from typing import Optional

import dash
from dash import html
from dash import Output, Input
import dash_file_cache as dfc


app = dash.Dash("demo")
service = dfc.ServiceData(dfc.CachePlain(1))
# highlight-next-line
service_mitm = dfc.ServiceDownloader("/dfc-downloader")
service.serve(app)
# highlight-next-line
service_mitm.serve(app)

app.layout = html.Div(
    (
        html.Div(html.Button(id="btn", children="Download")),
        # highlight-start
        dfc.Downloader(id="downloader", mitm="/dfc-downloader"),
        html.Div(id="trigger"),
        # highlight-end
    )
)


@app.callback(Output("downloader", "url"), Input("btn", "n_clicks"))
def a_callback_creating_data(n_clicks: Optional[int]) -> str:
    if not n_clicks:
        return dash.no_update
    address = service.register(
        fobj=io.StringIO("test file data..."),
        file_name="test.txt",
        mime_type="text/plain",
        one_time_service=True,
        download=True,
    )
    return address


@app.callback(
    Output("trigger", "children"),
    Input("downloader", "status"),
    prevent_initial_call=True,
)
def trigger_get_status(status: Optional[dfc.DownloaderStatus]):
    if not status:
        return dash.no_update
    return str(status)


if __name__ == "__main__":
    app.run()
```

相比于前例，`Downloader`的用法有以下不同：

* 需要设置一个特殊的`ServiceDownloader`服务，其路由设为`/dfc-downloader`。
* 同一路由也用于设置`dfc.Downloader(mitm=...)`的属性`mitm`。
* 使用一个`<div>`标签捕获`Downloader`的`status`属性。

属性`mitm`用来维持下载事件的激活状态。针对`mitm`属性的配置是十分有必要的。如果用户不设置它，则会使用默认的`mitm`属性。这种情况下，它会引用来自<IconLinkInline href="https://jimmywarting.github.io" text="jimmywarting的GitHub站点"/>的文件，就会造成离线情况下、不能正常工作的问题。透过设置`ServiceDownloader()`，`mitm`所需的文件可以配置在本地服务中。

:::danger

`Downloader`的`mitem`属性，需要配置得和`ServiceDownloader`的初始化参数相同。否则，用户可能会发现下载事件无法触发、且捕获不到任何错误信息。

:::

第二个callback捕获了`Downloader`在下载结束时触发的事件。所得的状态字典、包含了一条字符串状态码、和一条HTTP响应状态码。若下载事件成功完成，则字符状态码为`success`。

## 使用`Downloader`组件获取预配置过的跨域资源 {#use-a-downloader-component-for-fetching-a-preconfigured-cross-origin-resource}

在某些情况下，用户可能会需要在不同主机部署多个服务。设若以下脚本分别运行在两个不同的进程中，

<Tabs
  defaultValue="download"
  values={[
    { label: 'Dashboard：下载器', value: 'download', },
    { label: '服务：文件来源', value: 'source', },
  ]
}>

<TabItem value="download">

```python title="cross_origin_download.py" showLineNumbers
import io

from typing import Optional

import dash
from dash import html
from dash import Output, Input
import dash_file_cache as dfc


app = dash.Dash("demo")
service = dfc.ServiceData(dfc.CachePlain(1))
service_mitm = dfc.ServiceDownloader("/dfc-downloader")
service.serve(app)
service_mitm.serve(app)

app.layout = html.Div(
    (
        html.Div(html.Button(id="btn", children="Download")),
        # highlight-start
        dfc.Downloader(
            id="downloader", allow_cross_origin=True, mitm="/dfc-downloader"
        ),
        # highlight-end
        html.Div(id="trigger"),
    )
)


@app.callback(Output("downloader", "url"), Input("btn", "n_clicks"))
def a_callback_creating_data(n_clicks: Optional[int]) -> str:
    if not n_clicks:
        return dash.no_update
    return "http://127.0.0.1:8081/file"


@app.callback(
    Output("trigger", "children"),
    Input("downloader", "status"),
    prevent_initial_call=True,
)
def trigger_get_status(status: Optional[dfc.DownloaderStatus]):
    if not status:
        return dash.no_update
    return str(status)


if __name__ == "__main__":
    app.run(host="0.0.0.0", port="8080")
```

</TabItem>

<TabItem value="source">

```python title="service_source_file.py" showLineNumbers
import io
import flask
from dash_file_cache import CachePlain, ServiceData

app = flask.Flask("serve")

service = ServiceData(CachePlain(1), allowed_cross_origin="*")


@app.route("/file")
def file():
    addr = service.register(
        fobj=io.StringIO("test some files."),
        file_name="new.txt",
        mime_type="text/plain",
        download=True,
    )
    resp = flask.redirect(addr, code=302)
    resp.headers["Access-Control-Allow-Origin"] = "*"
    return resp


if __name__ == "__main__":
    service.serve(app)
    app.run(host="0.0.0.0", port=8081)
```

</TabItem>

</Tabs>

同时运行这些脚本。在dashboard这一侧，配置组件属性`allow_cross_origin`为`True`，从而允许下载器在可行的情况下、访问跨域资源。在这种情况下，发出的请求会按照[`cors`<IconExternalLink/>][link-cors]模式工作。

仅仅在dashboard一侧做跨域配置是不够的。在服务端，所提供的响应同样需要配置几条、和跨域调用有关的响应头。因此，上例中、将`allowed_cross_origin`设置为允许来自所有设备的跨域访问。在此情形下，`ServiceData`所提供的每个响应，都将自动配置好所需的跨域调用响应头。

:::warning

在被访问的数据一侧、配置跨域调用响应头是重中之重。若远端的资源没有配置成允许跨域，即使在下载器所在的这一段、配置了`allow_cross_origin`属性，也还是无法访问远端的资源。

:::

## 使用`Downloader`组件获取完全处于远端的文件 {#use-a-downloader-component-for-fetching-a-fully-remote-file}

某些情形下，可能需要访问远端的文件，但又没有办法为远端设备、做任何跨域服务的配置。这样的话，就可以使用一种基于代理的方法来访问跨站数据。

```python title="cross_site_download.py" showLineNumbers
import io

from typing import Optional

import dash
from dash import html
from dash import Output, Input
import dash_file_cache as dfc


app = dash.Dash("demo")
service = dfc.ServiceData(dfc.CachePlain(1))
service_mitm = dfc.ServiceDownloader("/dfc-downloader")
service.serve(app)
service_mitm.serve(app)

app.layout = html.Div(
    (
        html.Div(html.Button(id="btn", children="Download")),
        # highlight-next-line
        dfc.Downloader(id="downloader" mitm="/dfc-downloader"),
        html.Div(id="trigger"),
    )
)


@app.callback(Output("downloader", "url"), Input("btn", "n_clicks"))
def a_callback_creating_data(n_clicks: Optional[int]) -> str:
    if not n_clicks:
        return dash.no_update
    return service.register_request("https://testfile.org/1.3GBiconpng", download=True)


@app.callback(
    Output("trigger", "children"),
    Input("downloader", "status"),
    prevent_initial_call=True,
)
def trigger_get_status(status: Optional[dfc.DownloaderStatus]):
    if not status:
        return dash.no_update
    return str(status)


if __name__ == "__main__":
    app.run(host="0.0.0.0", port="8080")
```

方法`service.register_request`允许用户将某些指向远端资源的URL、注册到缓存中。这样一来，本地设备就会像代理服务器、或中间件一样工作。在访问该URL之前，缓存只包含文件的URL。一俟访问开始，则会逐块加载、并发送文件。针对每个文件块，数据先从远端站点下载到dashboard所在的主机。其后，将文件块传递给浏览器。由于浏览器只从dashboard主机获取文件，在此情形下、就不需要做任何跨域配置。

## 总结 {#summary}

下表总结、比较了不同下载器的用法。

|                                  | 大体量文件                        | 离线工作                          | 跨站访问文件                      | 捕获事件状态                      |
| -------------------------------- | --------------------------------- | --------------------------------- | --------------------------------- | --------------------------------- |
| `PlainDownloader()`              | <InlineIcon icon={vsiCheckIcon}/> | <InlineIcon icon={vsiCheckIcon}/> | <InlineIcon icon={vsiCheckIcon}/> |                                   |
| `Downloader()`                   | <InlineIcon icon={vsiCheckIcon}/> |                                   |                                   | <InlineIcon icon={vsiCheckIcon}/> |
| `Downloader(mitm=...)`           | <InlineIcon icon={vsiCheckIcon}/> | <InlineIcon icon={vsiCheckIcon}/> |                                   | <InlineIcon icon={vsiCheckIcon}/> |
| `Downloader(allow_cross_origin)` | <InlineIcon icon={vsiCheckIcon}/> |                                   | 仅允许跨域访问                    | <InlineIcon icon={vsiCheckIcon}/> |
| `url=service.register_request`   | <InlineIcon icon={vsiCheckIcon}/> |                                   | <InlineIcon icon={vsiCheckIcon}/> | <InlineIcon icon={vsiCheckIcon}/> |

请按照实际需要、妥善地配置下载器。一般来说，总是需要配置`mitm`属性，并且用户可以使用`service.register_request(...)`返回的缓存地址、获取来自因特网的任何文件。

[link-dccdownload]:https://dash.plotly.com/dash-core-components/download
[link-dash-sendfile]:https://github.com/plotly/dash/issues/1874
[link-flask-sendfile]:https://flask.palletsprojects.com/zh-cn/main/api/#flask.send_file
[link-flask-streamwcon]:https://flask.palletsprojects.com/zh-cn/main/api/#flask.stream_with_context
[link-filesaver]:https://www.npmjs.com/package/file-saver
[link-streamsaver]:https://github.com/jimmywarting/StreamSaver.js
[link-cors]:https://developer.mozilla.org/zh-CN/docs/Web/API/Request/mode
